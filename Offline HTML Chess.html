<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width,initial-scale=1.0,user-scalable=no"
		/>
		<title>Offline HTML Chess</title>
		<style>
			* {
				box-sizing: border-box;
				-webkit-tap-highlight-color: transparent;
				margin: 0;
				padding: 0;
			}
			body {
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
					sans-serif;
				background: #222;
				color: #eee;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: flex-start;
				min-height: 100vh;
				padding: 10px;
			}
			h1 {
				font-size: 20px;
				margin: 5px 0 8px 0;
				text-align: center;
			}
			#topBar {
				display: flex;
				flex-wrap: wrap;
				align-items: center;
				justify-content: center;
				margin-bottom: 6px;
				gap: 6px;
			}
			.label {
				font-size: 13px;
				margin-right: 4px;
			}
			select,
			input[type="range"] {
				font-size: 13px;
			}
			button {
				font-size: 13px;
				padding: 6px 10px;
				border: none;
				border-radius: 6px;
				background: #33694c;
				color: #fff;
				box-shadow: 0 3px #111;
				cursor: pointer;
				touch-action: manipulation;
			}
			button:active {
				transform: translateY(2px);
				box-shadow: 0 1px #111;
			}
			button:disabled {
				opacity: 0.5;
				cursor: not-allowed;
				box-shadow: none;
				transform: none;
			}
			#boardContainer {
				width: min(90vw, 480px);
				max-width: 480px;
				aspect-ratio: 1;
				margin: 4px auto;
				position: relative;
				border: 4px solid #404040;
				background: #000;
			}
			.board-row {
				display: flex;
				width: 100%;
				height: 12.5%;
			}
			.square {
				width: 12.5%;
				height: 100%;
				position: relative;
				touch-action: none;
			}
			.square.light {
				background: #999;
			}
			.square.dark {
				background: #33694c;
			}
			.coord {
				position: absolute;
				font-size: 10px;
				color: #333;
				font-weight: bold;
			}
			.coord.file {
				bottom: 2px;
				right: 3px;
			}
			.coord.rank {
				top: 2px;
				left: 3px;
			}
			.piece {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				font-size: calc(min(90vw, 480px) / 9);
				pointer-events: none;
				user-select: none;
				filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.3));
			}
			.piece.white {
				color: #fff;
			}
			.piece.black {
				color: #000;
			}
			.highlight-last {
				box-shadow: inset 0 0 0 3px rgba(255, 255, 0, 0.6);
			}
			.dragging {
				opacity: 0.7;
			}
			#statusBar {
				margin-top: 6px;
				font-size: 13px;
				text-align: center;
				min-height: 20px;
			}
			#controls2 {
				margin-top: 6px;
				display: flex;
				gap: 6px;
				flex-wrap: wrap;
				justify-content: center;
			}
			#stats {
				margin-top: 6px;
				font-size: 13px;
				text-align: center;
				color: #aaa;
			}
			#notationBox {
				margin-top: 10px;
				width: min(90vw, 480px);
				max-width: 480px;
				background: #111;
				border-radius: 6px;
				padding: 10px;
			}
			#notationHeader {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 8px;
			}
			#notationTitle {
				font-size: 14px;
				font-weight: bold;
			}
			#notationControls {
				display: flex;
				gap: 6px;
			}
			#notationControls button {
				font-size: 11px;
				padding: 4px 8px;
			}
			#notationContent {
				max-height: 150px;
				overflow-y: auto;
				font-family: monospace;
				font-size: 12px;
				line-height: 1.6;
				color: #ccc;
			}
			.move-pair {
				display: inline-block;
				margin-right: 12px;
				white-space: nowrap;
			}
			.move-number {
				color: #888;
				margin-right: 4px;
			}
			#gameOverModal {
				display: none;
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: rgba(0, 0, 0, 0.8);
				z-index: 1000;
				align-items: center;
				justify-content: center;
			}
			#gameOverContent {
				background: #2a2a2a;
				border-radius: 12px;
				padding: 30px;
				text-align: center;
				box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
			}
			#gameOverTitle {
				font-size: 32px;
				font-weight: bold;
				margin-bottom: 20px;
			}
			#gameOverTitle.won {
				color: #4caf50;
			}
			#gameOverTitle.lost {
				color: #f44336;
			}
			#gameOverButtons {
				display: flex;
				gap: 10px;
				justify-content: center;
				margin-top: 20px;
			}
			#gameOverButtons button {
				font-size: 16px;
				padding: 10px 20px;
			}
			@media (hover: hover) {
				.square:hover {
					outline: 2px solid rgba(255, 255, 255, 0.25);
				}
			}
		</style>
	</head>
	<body>
		<h1>Offline HTML Chess</h1>

		<div id="topBar">
			<span class="label">Play as</span>
			<select id="colorSelect">
				<option value="white" selected>White</option>
				<option value="black">Black</option>
			</select>
			<span class="label">Difficulty</span>
			<input id="difficulty" type="range" min="1" max="10" value="5" />
			<span id="difficultyValue">5</span>
			<button id="newGameBtn">New Game</button>
		</div>

		<div id="boardContainer"></div>

		<div id="controls2">
			<button id="undoBtn">Undo</button>
			<button id="flipBtn">Flip</button>
		</div>

		<div id="statusBar"></div>
		<div id="stats">
			Wins: <span id="winsCount">0</span> | Losses:
			<span id="lossesCount">0</span>
		</div>

		<div id="notationBox">
			<div id="notationHeader">
				<div id="notationTitle">Game Notation</div>
				<div id="notationControls">
					<button id="copyBtn">Copy</button>
					<button id="exportBtn">Export PGN</button>
				</div>
			</div>
			<div id="notationContent"></div>
		</div>

		<div id="gameOverModal">
			<div id="gameOverContent">
				<div id="gameOverTitle"></div>
				<div id="gameOverButtons">
					<button id="playAgainBtn">Play Again</button>
					<button id="closeModalBtn">Close</button>
				</div>
			</div>
		</div>

		<script>
			// Chess Engine
			(function () {
				var jsChessEngine = (function () {
					!(function (t, e) {
						"object" == typeof exports && "object" == typeof module
							? (module.exports = e())
							: "function" == typeof define && define.amd
							? define("js-chess-engine", [], e)
							: "object" == typeof exports
							? (exports["js-chess-engine"] = e())
							: (t["js-chess-engine"] = e());
					})(this, function () {
						return (function (t) {
							var e = {};
							function i(n) {
								if (e[n]) return e[n].exports;
								var o = (e[n] = { i: n, l: !1, exports: {} });
								return (
									t[n].call(o.exports, o, o.exports, i),
									(o.l = !0),
									o.exports
								);
							}
							return (
								(i.m = t),
								(i.c = e),
								(i.d = function (t, e, n) {
									i.o(t, e) ||
										Object.defineProperty(t, e, {
											enumerable: !0,
											get: n,
										});
								}),
								(i.r = function (t) {
									"undefined" != typeof Symbol &&
										Symbol.toStringTag &&
										Object.defineProperty(
											t,
											Symbol.toStringTag,
											{ value: "Module" }
										),
										Object.defineProperty(t, "__esModule", {
											value: !0,
										});
								}),
								(i.t = function (t, e) {
									if ((1 & e && (t = i(t)), 8 & e)) return t;
									if (
										4 & e &&
										"object" == typeof t &&
										t &&
										t.__esModule
									)
										return t;
									var n = Object.create(null);
									if (
										(i.r(n),
										Object.defineProperty(n, "default", {
											enumerable: !0,
											value: t,
										}),
										2 & e && "string" != typeof t)
									)
										for (var o in t)
											i.d(
												n,
												o,
												function (e) {
													return t[e];
												}.bind(null, o)
											);
									return n;
								}),
								(i.n = function (t) {
									var e =
										t && t.__esModule
											? function () {
													return t.default;
											  }
											: function () {
													return t;
											  };
									return i.d(e, "a", e), e;
								}),
								(i.o = function (t, e) {
									return Object.prototype.hasOwnProperty.call(
										t,
										e
									);
								}),
								(i.p = ""),
								i((i.s = 0))
							);
						})([
							function (t, e, i) {
								"use strict";
								i.r(e),
									i.d(e, "Game", function () {
										return $;
									}),
									i.d(e, "moves", function () {
										return J;
									}),
									i.d(e, "status", function () {
										return V;
									}),
									i.d(e, "getFen", function () {
										return Y;
									}),
									i.d(e, "move", function () {
										return z;
									}),
									i.d(e, "aiMove", function () {
										return X;
									});
								const n = [
										"A",
										"B",
										"C",
										"D",
										"E",
										"F",
										"G",
										"H",
									],
									o = [
										"1",
										"2",
										"3",
										"4",
										"5",
										"6",
										"7",
										"8",
									],
									s = {
										KING_W: "K",
										QUEEN_W: "Q",
										ROOK_W: "R",
										BISHOP_W: "B",
										KNIGHT_W: "N",
										PAWN_W: "P",
										KING_B: "k",
										QUEEN_B: "q",
										ROOK_B: "r",
										BISHOP_B: "b",
										KNIGHT_B: "n",
										PAWN_B: "p",
									},
									r = "black",
									c = "white",
									l = [0, 1, 2, 3, 4],
									a = { 0: 1, 1: 2, 2: 2, 3: 3, 4: 3, 5: 4 },
									u = { 0: 2, 1: 2, 2: 4, 3: 4, 4: 5, 5: 5 },
									h = {
										fullMove: 1,
										halfMove: 0,
										enPassant: null,
										isFinished: !1,
										checkMate: !1,
										check: !1,
										turn: c,
									},
									g = Object.assign(
										{
											pieces: {
												E1: "K",
												D1: "Q",
												A1: "R",
												H1: "R",
												C1: "B",
												F1: "B",
												B1: "N",
												G1: "N",
												A2: "P",
												B2: "P",
												C2: "P",
												D2: "P",
												E2: "P",
												F2: "P",
												G2: "P",
												H2: "P",
												E8: "k",
												D8: "q",
												A8: "r",
												H8: "r",
												C8: "b",
												F8: "b",
												B8: "n",
												G8: "n",
												A7: "p",
												B7: "p",
												C7: "p",
												D7: "p",
												E7: "p",
												F7: "p",
												G7: "p",
												H7: "p",
											},
											castling: {
												whiteShort: !0,
												blackShort: !0,
												whiteLong: !0,
												blackLong: !0,
											},
										},
										h
									),
									f = {
										UP: {
											A1: "A2",
											A2: "A3",
											A3: "A4",
											A4: "A5",
											A5: "A6",
											A6: "A7",
											A7: "A8",
											A8: null,
											B1: "B2",
											B2: "B3",
											B3: "B4",
											B4: "B5",
											B5: "B6",
											B6: "B7",
											B7: "B8",
											B8: null,
											C1: "C2",
											C2: "C3",
											C3: "C4",
											C4: "C5",
											C5: "C6",
											C6: "C7",
											C7: "C8",
											C8: null,
											D1: "D2",
											D2: "D3",
											D3: "D4",
											D4: "D5",
											D5: "D6",
											D6: "D7",
											D7: "D8",
											D8: null,
											E1: "E2",
											E2: "E3",
											E3: "E4",
											E4: "E5",
											E5: "E6",
											E6: "E7",
											E7: "E8",
											E8: null,
											F1: "F2",
											F2: "F3",
											F3: "F4",
											F4: "F5",
											F5: "F6",
											F6: "F7",
											F7: "F8",
											F8: null,
											G1: "G2",
											G2: "G3",
											G3: "G4",
											G4: "G5",
											G5: "G6",
											G6: "G7",
											G7: "G8",
											G8: null,
											H1: "H2",
											H2: "H3",
											H3: "H4",
											H4: "H5",
											H5: "H6",
											H6: "H7",
											H7: "H8",
											H8: null,
										},
										DOWN: {
											A1: null,
											A2: "A1",
											A3: "A2",
											A4: "A3",
											A5: "A4",
											A6: "A5",
											A7: "A6",
											A8: "A7",
											B1: null,
											B2: "B1",
											B3: "B2",
											B4: "B3",
											B5: "B4",
											B6: "B5",
											B7: "B6",
											B8: "B7",
											C1: null,
											C2: "C1",
											C3: "C2",
											C4: "C3",
											C5: "C4",
											C6: "C5",
											C7: "C6",
											C8: "C7",
											D1: null,
											D2: "D1",
											D3: "D2",
											D4: "D3",
											D5: "D4",
											D6: "D5",
											D7: "D6",
											D8: "D7",
											E1: null,
											E2: "E1",
											E3: "E2",
											E4: "E3",
											E5: "E4",
											E6: "E5",
											E7: "E6",
											E8: "E7",
											F1: null,
											F2: "F1",
											F3: "F2",
											F4: "F3",
											F5: "F4",
											F6: "F5",
											F7: "F6",
											F8: "F7",
											G1: null,
											G2: "G1",
											G3: "G2",
											G4: "G3",
											G5: "G4",
											G6: "G5",
											G7: "G6",
											G8: "G7",
											H1: null,
											H2: "H1",
											H3: "H2",
											H4: "H3",
											H5: "H4",
											H6: "H5",
											H7: "H6",
											H8: "H7",
										},
										LEFT: {
											A1: null,
											A2: null,
											A3: null,
											A4: null,
											A5: null,
											A6: null,
											A7: null,
											A8: null,
											B1: "A1",
											B2: "A2",
											B3: "A3",
											B4: "A4",
											B5: "A5",
											B6: "A6",
											B7: "A7",
											B8: "A8",
											C1: "B1",
											C2: "B2",
											C3: "B3",
											C4: "B4",
											C5: "B5",
											C6: "B6",
											C7: "B7",
											C8: "B8",
											D1: "C1",
											D2: "C2",
											D3: "C3",
											D4: "C4",
											D5: "C5",
											D6: "C6",
											D7: "C7",
											D8: "C8",
											E1: "D1",
											E2: "D2",
											E3: "D3",
											E4: "D4",
											E5: "D5",
											E6: "D6",
											E7: "D7",
											E8: "D8",
											F1: "E1",
											F2: "E2",
											F3: "E3",
											F4: "E4",
											F5: "E5",
											F6: "E6",
											F7: "E7",
											F8: "E8",
											G1: "F1",
											G2: "F2",
											G3: "F3",
											G4: "F4",
											G5: "F5",
											G6: "F6",
											G7: "F7",
											G8: "F8",
											H1: "G1",
											H2: "G2",
											H3: "G3",
											H4: "G4",
											H5: "G5",
											H6: "G6",
											H7: "G7",
											H8: "G8",
										},
										RIGHT: {
											A1: "B1",
											A2: "B2",
											A3: "B3",
											A4: "B4",
											A5: "B5",
											A6: "B6",
											A7: "B7",
											A8: "B8",
											B1: "C1",
											B2: "C2",
											B3: "C3",
											B4: "C4",
											B5: "C5",
											B6: "C6",
											B7: "C7",
											B8: "C8",
											C1: "D1",
											C2: "D2",
											C3: "D3",
											C4: "D4",
											C5: "D5",
											C6: "D6",
											C7: "D7",
											C8: "D8",
											D1: "E1",
											D2: "E2",
											D3: "E3",
											D4: "E4",
											D5: "E5",
											D6: "E6",
											D7: "E7",
											D8: "E8",
											E1: "F1",
											E2: "F2",
											E3: "F3",
											E4: "F4",
											E5: "F5",
											E6: "F6",
											E7: "F7",
											E8: "F8",
											F1: "G1",
											F2: "G2",
											F3: "G3",
											F4: "G4",
											F5: "G5",
											F6: "G6",
											F7: "G7",
											F8: "G8",
											G1: "H1",
											G2: "H2",
											G3: "H3",
											G4: "H4",
											G5: "H5",
											G6: "H6",
											G7: "H7",
											G8: "H8",
											H1: null,
											H2: null,
											H3: null,
											H4: null,
											H5: null,
											H6: null,
											H7: null,
											H8: null,
										},
										UP_LEFT: {
											A1: null,
											A2: null,
											A3: null,
											A4: null,
											A5: null,
											A6: null,
											A7: null,
											A8: null,
											B1: "A2",
											B2: "A3",
											B3: "A4",
											B4: "A5",
											B5: "A6",
											B6: "A7",
											B7: "A8",
											B8: null,
											C1: "B2",
											C2: "B3",
											C3: "B4",
											C4: "B5",
											C5: "B6",
											C6: "B7",
											C7: "B8",
											C8: null,
											D1: "C2",
											D2: "C3",
											D3: "C4",
											D4: "C5",
											D5: "C6",
											D6: "C7",
											D7: "C8",
											D8: null,
											E1: "D2",
											E2: "D3",
											E3: "D4",
											E4: "D5",
											E5: "D6",
											E6: "D7",
											E7: "D8",
											E8: null,
											F1: "E2",
											F2: "E3",
											F3: "E4",
											F4: "E5",
											F5: "E6",
											F6: "E7",
											F7: "E8",
											F8: null,
											G1: "F2",
											G2: "F3",
											G3: "F4",
											G4: "F5",
											G5: "F6",
											G6: "F7",
											G7: "F8",
											G8: null,
											H1: "G2",
											H2: "G3",
											H3: "G4",
											H4: "G5",
											H5: "G6",
											H6: "G7",
											H7: "G8",
											H8: null,
										},
										DOWN_RIGHT: {
											A1: null,
											A2: "B1",
											A3: "B2",
											A4: "B3",
											A5: "B4",
											A6: "B5",
											A7: "B6",
											A8: "B7",
											B1: null,
											B2: "C1",
											B3: "C2",
											B4: "C3",
											B5: "C4",
											B6: "C5",
											B7: "C6",
											B8: "C7",
											C1: null,
											C2: "D1",
											C3: "D2",
											C4: "D3",
											C5: "D4",
											C6: "D5",
											C7: "D6",
											C8: "D7",
											D1: null,
											D2: "E1",
											D3: "E2",
											D4: "E3",
											D5: "E4",
											D6: "E5",
											D7: "E6",
											D8: "E7",
											E1: null,
											E2: "F1",
											E3: "F2",
											E4: "F3",
											E5: "F4",
											E6: "F5",
											E7: "F6",
											E8: "F7",
											F1: null,
											F2: "G1",
											F3: "G2",
											F4: "G3",
											F5: "G4",
											F6: "G5",
											F7: "G6",
											F8: "G7",
											G1: null,
											G2: "H1",
											G3: "H2",
											G4: "H3",
											G5: "H4",
											G6: "H5",
											G7: "H6",
											G8: "H7",
											H1: null,
											H2: null,
											H3: null,
											H4: null,
											H5: null,
											H6: null,
											H7: null,
											H8: null,
										},
										UP_RIGHT: {
											A1: "B2",
											A2: "B3",
											A3: "B4",
											A4: "B5",
											A5: "B6",
											A6: "B7",
											A7: "B8",
											A8: null,
											B1: "C2",
											B2: "C3",
											B3: "C4",
											B4: "C5",
											B5: "C6",
											B6: "C7",
											B7: "C8",
											B8: null,
											C1: "D2",
											C2: "D3",
											C3: "D4",
											C4: "D5",
											C5: "D6",
											C6: "D7",
											C7: "D8",
											C8: null,
											D1: "E2",
											D2: "E3",
											D3: "E4",
											D4: "E5",
											D5: "E6",
											D6: "E7",
											D7: "E8",
											D8: null,
											E1: "F2",
											E2: "F3",
											E3: "F4",
											E4: "F5",
											E5: "F6",
											E6: "F7",
											E7: "F8",
											E8: null,
											F1: "G2",
											F2: "G3",
											F3: "G4",
											F4: "G5",
											F5: "G6",
											F6: "G7",
											F7: "G8",
											F8: null,
											G1: "H2",
											G2: "H3",
											G3: "H4",
											G4: "H5",
											G5: "H6",
											G6: "H7",
											G7: "H8",
											G8: null,
											H1: null,
											H2: null,
											H3: null,
											H4: null,
											H5: null,
											H6: null,
											H7: null,
											H8: null,
										},
										DOWN_LEFT: {
											A1: null,
											A2: null,
											A3: null,
											A4: null,
											A5: null,
											A6: null,
											A7: null,
											A8: null,
											B1: null,
											B2: "A1",
											B3: "A2",
											B4: "A3",
											B5: "A4",
											B6: "A5",
											B7: "A6",
											B8: "A7",
											C1: null,
											C2: "B1",
											C3: "B2",
											C4: "B3",
											C5: "B4",
											C6: "B5",
											C7: "B6",
											C8: "B7",
											D1: null,
											D2: "C1",
											D3: "C2",
											D4: "C3",
											D5: "C4",
											D6: "C5",
											D7: "C6",
											D8: "C7",
											E1: null,
											E2: "D1",
											E3: "D2",
											E4: "D3",
											E5: "D4",
											E6: "D5",
											E7: "D6",
											E8: "D7",
											F1: null,
											F2: "E1",
											F3: "E2",
											F4: "E3",
											F5: "E4",
											F6: "E5",
											F7: "E6",
											F8: "E7",
											G1: null,
											G2: "F1",
											G3: "F2",
											G4: "F3",
											G5: "F4",
											G6: "F5",
											G7: "F6",
											G8: "F7",
											H1: null,
											H2: "G1",
											H3: "G2",
											H4: "G3",
											H5: "G4",
											H6: "G5",
											H7: "G6",
											H8: "G7",
										},
									},
									C = [
										[0, 0, 0, 0, 0, 0, 0, 0],
										[5, 5, 5, 5, 5, 5, 5, 5],
										[1, 1, 2, 3, 3, 2, 1, 1],
										[0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5],
										[0, 0, 0, 2, 2, 0, 0, 0],
										[0.5, 0, 1, 0, 0, 1, 0, 0.5],
										[0.5, 0, 0, -2, -2, 0, 0, 0.5],
										[0, 0, 0, 0, 0, 0, 0, 0],
									],
									P = [
										[-4, -3, -2, -2, -2, -2, -3, -4],
										[-3, -2, 0, 0, 0, 0, -2, -3],
										[-2, 0, 1, 1.5, 1.5, 1, 0, -2],
										[-2, 0.5, 1.5, 2, 2, 1.5, 0.5, -2],
										[-2, 0, 1.5, 2, 2, 1.5, 0, -2],
										[-2, 0.5, 1, 1.5, 1.5, 1, 0.5, -2],
										[-3, -2, 0, 0.5, 0.5, 0, -2, -3],
										[-4, -3, -2, -2, -2, -2, -3, -4],
									],
									p = [
										[-2, -1, -1, -1, -1, -1, -1, -2],
										[-1, 0, 0, 0, 0, 0, 0, -1],
										[-1, 0, 0.5, 1, 1, 0.5, 0, -1],
										[-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1],
										[-1, 0, 1, 1, 1, 1, 0, -1],
										[-1, 1, 1, 1, 1, 1, 1, -1],
										[-1, 0.5, 0, 0, 0, 0, 0.5, -1],
										[-2, -1, -1, -1, -1, -1, -1, -2],
									],
									E = [
										[0, 0, 0, 0, 0, 0, 0, 0],
										[0.5, 1, 1, 1, 1, 1, 1, 0.5],
										[-0.5, 0, 0, 0, 0, 0, 0, -0.5],
										[-0.5, 0, 0, 0, 0, 0, 0, -0.5],
										[-0.5, 0, 0, 0, 0, 0, 0, -0.5],
										[-0.5, 0, 0, 0, 0, 0, 0, -0.5],
										[-0.5, 0, 0, 0, 0, 0, 0, -0.5],
										[0, 0, 0, 0.5, 0.5, 0, 0, 0],
									],
									B = [
										[-3, -4, -4, -5, -5, -4, -4, -3],
										[-3, -4, -4, -5, -5, -4, -4, -3],
										[-3, -4, -4, -5, -5, -4, -4, -3],
										[-3, -4, -4, -5, -5, -4, -4, -3],
										[-2, -3, -3, -4, -4, -3, -3, -2],
										[-1, -2, -2, -2, -2, -2, -2, -1],
										[2, 2, 0, 0, 0, 0, 2, 2],
										[2, 3, 1, 0, 0, 1, 3, 2],
									],
									F = [
										[-2, -1, -1, -0.5, -0.5, -1, -1, -2],
										[-1, 0, 0, 0, 0, 0, 0, -1],
										[-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1],
										[-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],
										[0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],
										[-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1],
										[-1, 0, 0.5, 0, 0, 0, 0, -1],
										[-2, -1, -1, -0.5, -0.5, -1, -1, -2],
									],
									G = {
										P: C.slice().reverse(),
										p: C,
										N: P.slice().reverse(),
										n: P,
										B: p.slice().reverse(),
										b: p,
										R: E.slice().reverse(),
										r: E,
										K: B.slice().reverse(),
										k: B,
										Q: F.slice().reverse(),
										q: F,
									};
								function D(t) {
									return f.UP[t];
								}
								function A(t) {
									return f.DOWN[t];
								}
								function H(t) {
									return f.LEFT[t];
								}
								function b(t) {
									return f.RIGHT[t];
								}
								function d(t) {
									return f.UP_LEFT[t];
								}
								function k(t) {
									return f.UP_RIGHT[t];
								}
								function v(t) {
									return f.DOWN_LEFT[t];
								}
								function y(t) {
									return f.DOWN_RIGHT[t];
								}
								function w(t) {
									const e = d(t);
									return e ? D(e) : null;
								}
								function O(t) {
									const e = d(t);
									return e ? H(e) : null;
								}
								function L(t) {
									const e = k(t);
									return e ? D(e) : null;
								}
								function m(t) {
									const e = k(t);
									return e ? b(e) : null;
								}
								function M(t) {
									const e = v(t);
									return e ? A(e) : null;
								}
								function K(t) {
									const e = v(t);
									return e ? H(e) : null;
								}
								function N(t) {
									const e = y(t);
									return e ? A(e) : null;
								}
								function S(t) {
									const e = y(t);
									return e ? b(e) : null;
								}
								function j(t, e) {
									return e === c ? f.UP[t] : f.DOWN[t];
								}
								function _(t, e) {
									return e === c
										? f.UP_LEFT[t]
										: f.DOWN_RIGHT[t];
								}
								function W(t, e) {
									return e === c
										? f.UP_RIGHT[t]
										: f.DOWN_LEFT[t];
								}
								function U(t, e) {
									return e === c
										? f.DOWN_LEFT[t]
										: f.UP_RIGHT[t];
								}
								function R(t, e) {
									return e === c
										? f.DOWN_RIGHT[t]
										: f.UP_LEFT[t];
								}
								function T(t) {
									return (
										{ k: 10, q: 9, r: 5, b: 3, n: 3, p: 1 }[
											t.toLowerCase()
										] || 0
									);
								}
								function I(t) {
									return (
										"string" == typeof t &&
										t.match("^[a-hA-H]{1}[1-8]{1}$")
									);
								}
								const x = -1e3,
									Q = 1e3;
								class q {
									constructor(
										t = JSON.parse(JSON.stringify(g))
									) {
										if ("object" == typeof t)
											this.configuration = Object.assign(
												{},
												h,
												t
											);
										else {
											if ("string" != typeof t)
												throw new Error(
													"Unknown configuration type " +
														typeof config +
														"."
												);
											this.configuration = Object.assign(
												{},
												h,
												(function (t = "") {
													const [e, i, s, l, a, u] =
															t.split(" "),
														h = {
															pieces: Object.fromEntries(
																e
																	.split("/")
																	.flatMap(
																		(
																			t,
																			e
																		) => {
																			let i = 0;
																			return t
																				.split(
																					""
																				)
																				.reduce(
																					(
																						t,
																						s
																					) => {
																						const r =
																							s.match(
																								/k|b|q|n|p|r/i
																							);
																						r &&
																							(t.push(
																								[
																									n[
																										i
																									] +
																										o[
																											7 -
																												e
																										],
																									r[0],
																								]
																							),
																							(i += 1));
																						const c =
																							s.match(
																								/[1-8]/
																							);
																						return (
																							c &&
																								(i +=
																									Number(
																										c
																									)),
																							t
																						);
																					},
																					[]
																				);
																		}
																	)
															),
														};
													return (
														(h.turn =
															"b" === i ? r : c),
														(h.castling = {
															whiteLong: !1,
															whiteShort: !1,
															blackLong: !1,
															blackShort: !1,
														}),
														s.includes("K") &&
															(h.castling.whiteShort =
																!0),
														s.includes("k") &&
															(h.castling.blackShort =
																!0),
														s.includes("Q") &&
															(h.castling.whiteLong =
																!0),
														s.includes("q") &&
															(h.castling.blackLong =
																!0),
														I(l) &&
															(h.enPassant =
																l.toUpperCase()),
														(h.halfMove =
															parseInt(a)),
														(h.fullMove =
															parseInt(u)),
														h
													);
												})(t)
											);
										}
										this.configuration.castling ||
											(this.configuration.castling = {
												whiteShort: !0,
												blackShort: !0,
												whiteLong: !0,
												blackLong: !0,
											}),
											(this.history = []);
									}
									getAttackingFields(
										t = this.getPlayingColor()
									) {
										let e = [];
										for (const i in this.configuration
											.pieces) {
											const n = this.getPiece(i);
											this.getPieceColor(n) === t &&
												(e = [
													...e,
													...this.getPieceMoves(n, i),
												]);
										}
										return e;
									}
									isAttackingKing(
										t = this.getPlayingColor()
									) {
										let e = null;
										for (const i in this.configuration
											.pieces) {
											const n = this.getPiece(i);
											if (
												this.isKing(n) &&
												this.getPieceColor(n) !== t
											) {
												e = i;
												break;
											}
										}
										return this.isPieceUnderAttack(e);
									}
									isPieceUnderAttack(t) {
										const e =
												this.getPieceOnLocationColor(t),
											i = this.getEnemyColor(e);
										let n = !1,
											o = t,
											s = 0;
										for (; D(o) && !n; ) {
											(o = D(o)), s++;
											const t = this.getPiece(o);
											if (
												(t &&
													this.getPieceColor(t) ===
														i &&
													(this.isRook(t) ||
														this.isQueen(t) ||
														(this.isKing(t) &&
															1 === s)) &&
													(n = !0),
												t)
											)
												break;
										}
										for (o = t, s = 0; A(o) && !n; ) {
											(o = A(o)), s++;
											const t = this.getPiece(o);
											if (
												(t &&
													this.getPieceColor(t) ===
														i &&
													(this.isRook(t) ||
														this.isQueen(t) ||
														(this.isKing(t) &&
															1 === s)) &&
													(n = !0),
												t)
											)
												break;
										}
										for (o = t, s = 0; H(o) && !n; ) {
											(o = H(o)), s++;
											const t = this.getPiece(o);
											if (
												(t &&
													this.getPieceColor(t) ===
														i &&
													(this.isRook(t) ||
														this.isQueen(t) ||
														(this.isKing(t) &&
															1 === s)) &&
													(n = !0),
												t)
											)
												break;
										}
										for (o = t, s = 0; b(o) && !n; ) {
											(o = b(o)), s++;
											const t = this.getPiece(o);
											if (
												(t &&
													this.getPieceColor(t) ===
														i &&
													(this.isRook(t) ||
														this.isQueen(t) ||
														(this.isKing(t) &&
															1 === s)) &&
													(n = !0),
												t)
											)
												break;
										}
										for (o = t, s = 0; W(o, e) && !n; ) {
											(o = W(o, e)), s++;
											const t = this.getPiece(o);
											if (
												(t &&
													this.getPieceColor(t) ===
														i &&
													(this.isBishop(t) ||
														this.isQueen(t) ||
														(1 === s &&
															(this.isKing(t) ||
																this.isPawn(
																	t
																)))) &&
													(n = !0),
												t)
											)
												break;
										}
										for (o = t, s = 0; _(o, e) && !n; ) {
											(o = _(o, e)), s++;
											const t = this.getPiece(o);
											if (
												(t &&
													this.getPieceColor(t) ===
														i &&
													(this.isBishop(t) ||
														this.isQueen(t) ||
														(1 === s &&
															(this.isKing(t) ||
																this.isPawn(
																	t
																)))) &&
													(n = !0),
												t)
											)
												break;
										}
										for (o = t, s = 0; R(o, e) && !n; ) {
											(o = R(o, e)), s++;
											const t = this.getPiece(o);
											if (
												(t &&
													this.getPieceColor(t) ===
														i &&
													(this.isBishop(t) ||
														this.isQueen(t) ||
														(this.isKing(t) &&
															1 === s)) &&
													(n = !0),
												t)
											)
												break;
										}
										for (o = t, s = 0; U(o, e) && !n; ) {
											(o = U(o, e)), s++;
											const t = this.getPiece(o);
											if (
												(t &&
													this.getPieceColor(t) ===
														i &&
													(this.isBishop(t) ||
														this.isQueen(t) ||
														(this.isKing(t) &&
															1 === s)) &&
													(n = !0),
												t)
											)
												break;
										}
										o = L(t);
										let r = this.getPiece(o);
										return (
											r &&
												this.getPieceColor(r) === i &&
												this.isKnight(r) &&
												(n = !0),
											(o = m(t)),
											(r = this.getPiece(o)),
											r &&
												this.getPieceColor(r) === i &&
												this.isKnight(r) &&
												(n = !0),
											(o = O(t)),
											(r = this.getPiece(o)),
											r &&
												this.getPieceColor(r) === i &&
												this.isKnight(r) &&
												(n = !0),
											(o = w(t)),
											(r = this.getPiece(o)),
											r &&
												this.getPieceColor(r) === i &&
												this.isKnight(r) &&
												(n = !0),
											(o = M(t)),
											(r = this.getPiece(o)),
											r &&
												this.getPieceColor(r) === i &&
												this.isKnight(r) &&
												(n = !0),
											(o = K(t)),
											(r = this.getPiece(o)),
											r &&
												this.getPieceColor(r) === i &&
												this.isKnight(r) &&
												(n = !0),
											(o = N(t)),
											(r = this.getPiece(o)),
											r &&
												this.getPieceColor(r) === i &&
												this.isKnight(r) &&
												(n = !0),
											(o = S(t)),
											(r = this.getPiece(o)),
											r &&
												this.getPieceColor(r) === i &&
												this.isKnight(r) &&
												(n = !0),
											n
										);
									}
									hasPlayingPlayerCheck() {
										return this.isAttackingKing(
											this.getNonPlayingColor()
										);
									}
									hasNonPlayingPlayerCheck() {
										return this.isAttackingKing(
											this.getPlayingColor()
										);
									}
									getLowestValuePieceAttackingLocation(
										t,
										e = this.getPlayingColor()
									) {
										let i = null;
										for (const n in this.configuration
											.pieces) {
											const o = this.getPiece(n);
											this.getPieceColor(o) === e &&
												this.getPieceMoves(o, n).map(
													(e) => {
														e === t &&
															(null === i ||
																T(o) < i) &&
															(i = T(o));
													}
												);
										}
										return i;
									}
									getMoves(
										t = this.getPlayingColor(),
										e = null
									) {
										const i = {};
										let n = 0;
										for (const e in this.configuration
											.pieces) {
											const o = this.getPiece(e);
											if (this.getPieceColor(o) === t) {
												const t = this.getPieceMoves(
													o,
													e
												);
												t.length && n++,
													Object.assign(i, {
														[e]: t,
													});
											}
										}
										const o = this.getAttackingFields(
											this.getNonPlayingColor()
										);
										if (
											(this.isLeftCastlingPossible(o) &&
												(this.isPlayingWhite() &&
													i.E1 &&
													i.E1.push("C1"),
												this.isPlayingBlack() &&
													i.E8 &&
													i.E8.push("C8")),
											this.isRightCastlingPossible(o) &&
												(this.isPlayingWhite() &&
													i.E1 &&
													i.E1.push("G1"),
												this.isPlayingBlack() &&
													i.E8 &&
													i.E8.push("G8")),
											e && n > e)
										)
											return i;
										const s = {};
										for (const t in i)
											i[t].map((e) => {
												const i = {
														pieces: Object.assign(
															{},
															this.configuration
																.pieces
														),
														castling: Object.assign(
															{},
															this.configuration
																.castling
														),
													},
													n = new q(i);
												n.move(t, e),
													((this.isPlayingWhite() &&
														!n.isAttackingKing(
															r
														)) ||
														(this.isPlayingBlack() &&
															!n.isAttackingKing(
																c
															))) &&
														(s[t] || (s[t] = []),
														s[t].push(e));
											});
										return (
											Object.keys(s).length ||
												((this.configuration.isFinished =
													!0),
												this.hasPlayingPlayerCheck() &&
													(this.configuration.checkMate =
														!0)),
											s
										);
									}
									isLeftCastlingPossible(t) {
										if (
											this.isPlayingWhite() &&
											!this.configuration.castling
												.whiteLong
										)
											return !1;
										if (
											this.isPlayingBlack() &&
											!this.configuration.castling
												.blackLong
										)
											return !1;
										let e = null;
										if (
											(this.isPlayingWhite() &&
											"K" === this.getPiece("E1") &&
											"R" === this.getPiece("A1") &&
											!t.includes("E1")
												? (e = "E1")
												: this.isPlayingBlack() &&
												  "k" === this.getPiece("E8") &&
												  "r" === this.getPiece("A8") &&
												  !t.includes("E8") &&
												  (e = "E8"),
											!e)
										)
											return !1;
										let i = H(e);
										return (
											!this.getPiece(i) &&
											!t.includes(i) &&
											((i = H(i)),
											!this.getPiece(i) &&
												!t.includes(i) &&
												((i = H(i)), !this.getPiece(i)))
										);
									}
									isRightCastlingPossible(t) {
										if (
											this.isPlayingWhite() &&
											!this.configuration.castling
												.whiteShort
										)
											return !1;
										if (
											this.isPlayingBlack() &&
											!this.configuration.castling
												.blackShort
										)
											return !1;
										let e = null;
										if (
											(this.isPlayingWhite() &&
											"K" === this.getPiece("E1") &&
											"R" === this.getPiece("H1") &&
											!t.includes("E1")
												? (e = "E1")
												: this.isPlayingBlack() &&
												  "k" === this.getPiece("E8") &&
												  "r" === this.getPiece("H8") &&
												  !t.includes("E8") &&
												  (e = "E8"),
											!e)
										)
											return !1;
										let i = b(e);
										return (
											!this.getPiece(i) &&
											!t.includes(i) &&
											((i = b(i)),
											!this.getPiece(i) && !t.includes(i))
										);
									}
									getPieceMoves(t, e) {
										return this.isPawn(t)
											? this.getPawnMoves(t, e)
											: this.isKnight(t)
											? this.getKnightMoves(t, e)
											: this.isRook(t)
											? this.getRookMoves(t, e)
											: this.isBishop(t)
											? this.getBishopMoves(t, e)
											: this.isQueen(t)
											? this.getQueenMoves(t, e)
											: this.isKing(t)
											? this.getKingMoves(t, e)
											: [];
									}
									isPawn(t) {
										return "P" === t.toUpperCase();
									}
									isKnight(t) {
										return "N" === t.toUpperCase();
									}
									isRook(t) {
										return "R" === t.toUpperCase();
									}
									isBishop(t) {
										return "B" === t.toUpperCase();
									}
									isQueen(t) {
										return "Q" === t.toUpperCase();
									}
									isKing(t) {
										return "K" === t.toUpperCase();
									}
									getPawnMoves(t, e) {
										const i = [],
											n = this.getPieceColor(t);
										let o = j(e, n);
										return (
											o &&
												!this.getPiece(o) &&
												(i.push(o),
												(o = j(o, n)),
												(function (t, e) {
													if (t === c && "2" === e[1])
														return !0;
													if (t === r && "7" === e[1])
														return !0;
													return !1;
												})(n, e) &&
													o &&
													!this.getPiece(o) &&
													i.push(o)),
											(o = _(e, n)),
											o &&
												((this.getPiece(o) &&
													this.getPieceOnLocationColor(
														o
													) !== n) ||
													o ===
														this.configuration
															.enPassant) &&
												i.push(o),
											(o = W(e, n)),
											o &&
												((this.getPiece(o) &&
													this.getPieceOnLocationColor(
														o
													) !== n) ||
													o ===
														this.configuration
															.enPassant) &&
												i.push(o),
											i
										);
									}
									getKnightMoves(t, e) {
										const i = [],
											n = this.getPieceColor(t);
										let o = L(e);
										return (
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = m(e)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = w(e)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = O(e)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = K(e)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = M(e)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = S(e)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = N(e)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											i
										);
									}
									getRookMoves(t, e) {
										const i = [],
											n = this.getPieceColor(t);
										let o = e;
										for (; D(o); ) {
											o = D(o);
											const t =
												this.getPieceOnLocationColor(o);
											if (
												(this.getPieceOnLocationColor(
													o
												) !== n && i.push(o),
												t)
											)
												break;
										}
										for (o = e; A(o); ) {
											o = A(o);
											const t =
												this.getPieceOnLocationColor(o);
											if (
												(this.getPieceOnLocationColor(
													o
												) !== n && i.push(o),
												t)
											)
												break;
										}
										for (o = e; b(o); ) {
											o = b(o);
											const t =
												this.getPieceOnLocationColor(o);
											if (
												(this.getPieceOnLocationColor(
													o
												) !== n && i.push(o),
												t)
											)
												break;
										}
										for (o = e; H(o); ) {
											o = H(o);
											const t =
												this.getPieceOnLocationColor(o);
											if (
												(this.getPieceOnLocationColor(
													o
												) !== n && i.push(o),
												t)
											)
												break;
										}
										return i;
									}
									getBishopMoves(t, e) {
										const i = [],
											n = this.getPieceColor(t);
										let o = e;
										for (; d(o); ) {
											o = d(o);
											const t =
												this.getPieceOnLocationColor(o);
											if (
												(this.getPieceOnLocationColor(
													o
												) !== n && i.push(o),
												t)
											)
												break;
										}
										for (o = e; k(o); ) {
											o = k(o);
											const t =
												this.getPieceOnLocationColor(o);
											if (
												(this.getPieceOnLocationColor(
													o
												) !== n && i.push(o),
												t)
											)
												break;
										}
										for (o = e; v(o); ) {
											o = v(o);
											const t =
												this.getPieceOnLocationColor(o);
											if (
												(this.getPieceOnLocationColor(
													o
												) !== n && i.push(o),
												t)
											)
												break;
										}
										for (o = e; y(o); ) {
											o = y(o);
											const t =
												this.getPieceOnLocationColor(o);
											if (
												(this.getPieceOnLocationColor(
													o
												) !== n && i.push(o),
												t)
											)
												break;
										}
										return i;
									}
									getQueenMoves(t, e) {
										return [
											...this.getRookMoves(t, e),
											...this.getBishopMoves(t, e),
										];
									}
									getKingMoves(t, e) {
										const i = [],
											n = this.getPieceColor(t);
										let o = e;
										return (
											(o = D(o)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = e),
											(o = b(o)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = e),
											(o = A(o)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = e),
											(o = H(o)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = e),
											(o = d(o)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = e),
											(o = k(o)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = e),
											(o = v(o)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											(o = e),
											(o = y(o)),
											o &&
												this.getPieceOnLocationColor(
													o
												) !== n &&
												i.push(o),
											i
										);
									}
									getPieceColor(t) {
										return t.toUpperCase() === t ? c : r;
									}
									getPieceOnLocationColor(t) {
										const e = this.getPiece(t);
										return e
											? e.toUpperCase() === e
												? c
												: r
											: null;
									}
									getPiece(t) {
										return this.configuration.pieces[t];
									}
									setPiece(t, e) {
										if (
											!(function (t) {
												return Object.values(
													s
												).includes(t);
											})(e)
										)
											throw new Error(
												"Invalid piece " + e
											);
										if (!I(t))
											throw new Error(
												"Invalid location " + t
											);
										this.configuration.pieces[
											t.toUpperCase()
										] = e;
									}
									removePiece(t) {
										if (!I(t))
											throw new Error(
												"Invalid location " + t
											);
										delete this.configuration.pieces[
											t.toUpperCase()
										];
									}
									isEmpty(t) {
										if (!I(t))
											throw new Error(
												"Invalid location " + t
											);
										return !this.configuration.pieces[
											t.toUpperCase()
										];
									}
									getEnemyColor(t) {
										return t === c ? r : c;
									}
									getPlayingColor() {
										return this.configuration.turn;
									}
									getNonPlayingColor() {
										return this.isPlayingWhite() ? r : c;
									}
									isPlayingWhite() {
										return this.configuration.turn === c;
									}
									isPlayingBlack() {
										return this.configuration.turn === r;
									}
									addMoveToHistory(t, e) {
										const i = JSON.parse(
											JSON.stringify(this.configuration)
										);
										(i.check =
											this.hasPlayingPlayerCheck()),
											this.history.push({
												from: t,
												to: e,
												configuration: i,
											});
									}
									move(t, e) {
										const i = this.getPiece(t),
											n = this.getPiece(e);
										if (!i)
											throw new Error(
												"There is no piece at " + t
											);
										var o, s;
										if (
											(Object.assign(
												this.configuration.pieces,
												{ [e]: i }
											),
											delete this.configuration.pieces[t],
											this.isPlayingWhite() &&
												this.isPawn(i) &&
												"8" === e[1] &&
												Object.assign(
													this.configuration.pieces,
													{ [e]: "Q" }
												),
											this.isPlayingBlack() &&
												this.isPawn(i) &&
												"1" === e[1] &&
												Object.assign(
													this.configuration.pieces,
													{ [e]: "q" }
												),
											this.isPawn(i) &&
												e ===
													this.configuration
														.enPassant &&
												delete this.configuration
													.pieces[
													((o = e),
													(s =
														this.getPlayingColor()),
													s === c
														? f.DOWN[o]
														: f.UP[o])
												],
											this.isPawn(i) &&
											this.isPlayingWhite() &&
											"2" === t[1] &&
											"4" === e[1]
												? (this.configuration.enPassant =
														t[0] + "3")
												: this.isPawn(i) &&
												  this.isPlayingBlack() &&
												  "7" === t[1] &&
												  "5" === e[1]
												? (this.configuration.enPassant =
														t[0] + "6")
												: (this.configuration.enPassant =
														null),
											"E1" === t &&
												Object.assign(
													this.configuration.castling,
													{
														whiteLong: !1,
														whiteShort: !1,
													}
												),
											"E8" === t &&
												Object.assign(
													this.configuration.castling,
													{
														blackLong: !1,
														blackShort: !1,
													}
												),
											"A1" === t &&
												Object.assign(
													this.configuration.castling,
													{ whiteLong: !1 }
												),
											"H1" === t &&
												Object.assign(
													this.configuration.castling,
													{ whiteShort: !1 }
												),
											"A8" === t &&
												Object.assign(
													this.configuration.castling,
													{ blackLong: !1 }
												),
											"H8" === t &&
												Object.assign(
													this.configuration.castling,
													{ blackShort: !1 }
												),
											this.isKing(i))
										) {
											if ("E1" === t && "C1" === e)
												return this.move("A1", "D1");
											if ("E8" === t && "C8" === e)
												return this.move("A8", "D8");
											if ("E1" === t && "G1" === e)
												return this.move("H1", "F1");
											if ("E8" === t && "G8" === e)
												return this.move("H8", "F8");
										}
										(this.configuration.turn =
											this.isPlayingWhite() ? r : c),
											this.isPlayingWhite() &&
												this.configuration.fullMove++,
											this.configuration.halfMove++,
											(n || this.isPawn(i)) &&
												(this.configuration.halfMove = 0);
									}
									exportJson() {
										return {
											moves: this.getMoves(),
											pieces: this.configuration.pieces,
											turn: this.configuration.turn,
											isFinished:
												this.configuration.isFinished,
											check: this.hasPlayingPlayerCheck(),
											checkMate:
												this.configuration.checkMate,
											castling:
												this.configuration.castling,
											enPassant:
												this.configuration.enPassant,
											halfMove:
												this.configuration.halfMove,
											fullMove:
												this.configuration.fullMove,
										};
									}
									calculateAiMove(t) {
										return this.calculateAiMoves(t)[0];
									}
									calculateAiMoves(t) {
										if (((t = parseInt(t)), !l.includes(t)))
											throw new Error(
												"Invalid level " +
													t +
													". You can choose " +
													l.join(",")
											);
										this.shouldIncreaseLevel() && t++;
										const e = [],
											i = this.calculateScore(
												this.getPlayingColor()
											),
											n = this.getMoves();
										for (const o in n)
											n[o].map((n) => {
												const s = this.getTestBoard(),
													r = Boolean(s.getPiece(n));
												s.move(o, n),
													e.push({
														from: o,
														to: n,
														score:
															s.testMoveScores(
																this.getPlayingColor(),
																t,
																r,
																r
																	? s.calculateScore(
																			this.getPlayingColor()
																	  )
																	: i,
																n
															).score +
															s.calculateScoreByPiecesLocation(
																this.getPlayingColor()
															) +
															Math.floor(
																Math.random() *
																	(this
																		.configuration
																		.halfMove >
																	10
																		? this
																				.configuration
																				.halfMove -
																		  10
																		: 1) *
																	10
															) /
																10,
													});
											});
										return (
											e.sort((t, e) =>
												t.score < e.score
													? 1
													: t.score > e.score
													? -1
													: 0
											),
											e
										);
									}
									shouldIncreaseLevel() {
										return this.getIngamePiecesValue() < 50;
									}
									getIngamePiecesValue() {
										let t = 0;
										for (const e in this.configuration
											.pieces) {
											t += T(this.getPiece(e));
										}
										return t;
									}
									getTestBoard() {
										const t = {
											pieces: Object.assign(
												{},
												this.configuration.pieces
											),
											castling: Object.assign(
												{},
												this.configuration.castling
											),
											turn: this.configuration.turn,
											enPassant:
												this.configuration.enPassant,
										};
										return new q(t);
									}
									testMoveScores(t, e, i, n, o, s = 1) {
										let r = null;
										if (
											(s < u[e] &&
											this.hasPlayingPlayerCheck()
												? (r = this.getMoves(
														this.getPlayingColor()
												  ))
												: (s < a[e] ||
														(i && s < u[e])) &&
												  (r = this.getMoves(
														this.getPlayingColor(),
														5
												  )),
											this.configuration.isFinished)
										)
											return {
												score:
													this.calculateScore(t) +
													(this.getPlayingColor() ===
													t
														? s
														: -s),
												max: !0,
											};
										if (!r) {
											if (null !== n)
												return { score: n, max: !1 };
											return {
												score: this.calculateScore(t),
												max: !1,
											};
										}
										let c =
												this.getPlayingColor() === t
													? x
													: Q,
											l = !1;
										for (const i in r)
											l ||
												r[i].map((o) => {
													if (l) return;
													const r =
															this.getTestBoard(),
														a = Boolean(
															r.getPiece(o)
														);
													if (
														(r.move(i, o),
														r.hasNonPlayingPlayerCheck())
													)
														return;
													const u = r.testMoveScores(
														t,
														e,
														a,
														a
															? r.calculateScore(
																	t
															  )
															: n,
														o,
														s + 1
													);
													u.max && (l = !0),
														(c =
															this.getPlayingColor() ===
															t
																? Math.max(
																		c,
																		u.score
																  )
																: Math.min(
																		c,
																		u.score
																  ));
												});
										return { score: c, max: !1 };
									}
									calculateScoreByPiecesLocation(
										t = this.getPlayingColor()
									) {
										const e = {
											A: 0,
											B: 1,
											C: 2,
											D: 3,
											E: 4,
											F: 5,
											G: 6,
											H: 7,
										};
										let i = 0;
										for (const n in this.configuration
											.pieces) {
											const o = this.getPiece(n);
											if (G[o]) {
												const s =
													G[o][n[1] - 1][e[n[0]]];
												i +=
													0.5 *
													(this.getPieceColor(o) === t
														? s
														: -s);
											}
										}
										return i;
									}
									calculateScore(t = this.getPlayingColor()) {
										let e = 0;
										if (this.configuration.checkMate)
											return this.getPlayingColor() === t
												? x
												: Q;
										if (this.configuration.isFinished)
											return this.getPlayingColor() === t
												? Q
												: x;
										for (const i in this.configuration
											.pieces) {
											const n = this.getPiece(i);
											this.getPieceColor(n) === t
												? (e += 10 * T(n))
												: (e -= 10 * T(n));
										}
										return e;
									}
								}
								class $ {
									constructor(t) {
										this.board = new q(t);
									}
									move(t, e) {
										(t = t.toUpperCase()),
											(e = e.toUpperCase());
										const i = this.board.getMoves();
										if (!i[t] || !i[t].includes(e))
											throw new Error(
												"Invalid move from " +
													t +
													" to " +
													e +
													" for " +
													this.board.getPlayingColor()
											);
										return (
											this.board.addMoveToHistory(t, e),
											this.board.move(t, e),
											{ [t]: e }
										);
									}
									moves(t = null) {
										return (
											(t
												? this.board.getMoves()[
														t.toUpperCase()
												  ]
												: this.board.getMoves()) || []
										);
									}
									setPiece(t, e) {
										this.board.setPiece(t, e);
									}
									removePiece(t) {
										this.board.removePiece(t);
									}
									aiMove(t = 2) {
										const e = this.board.calculateAiMove(t);
										return this.move(e.from, e.to);
									}
									getHistory(t = !1) {
										return t
											? this.board.history.reverse()
											: this.board.history;
									}
									printToConsole() {
										!(function (t) {
											process.stdout.write("\n");
											let e = c;
											Object.assign([], o)
												.reverse()
												.map((i) => {
													process.stdout.write(
														"" + i
													),
														n.map((n) => {
															switch (
																t.pieces[n + i]
															) {
																case "K":
																	process.stdout.write(
																		""
																	);
																	break;
																case "Q":
																	process.stdout.write(
																		""
																	);
																	break;
																case "R":
																	process.stdout.write(
																		""
																	);
																	break;
																case "B":
																	process.stdout.write(
																		""
																	);
																	break;
																case "N":
																	process.stdout.write(
																		""
																	);
																	break;
																case "P":
																	process.stdout.write(
																		""
																	);
																	break;
																case "k":
																	process.stdout.write(
																		""
																	);
																	break;
																case "q":
																	process.stdout.write(
																		""
																	);
																	break;
																case "r":
																	process.stdout.write(
																		""
																	);
																	break;
																case "b":
																	process.stdout.write(
																		""
																	);
																	break;
																case "n":
																	process.stdout.write(
																		""
																	);
																	break;
																case "p":
																	process.stdout.write(
																		""
																	);
																	break;
																default:
																	process.stdout.write(
																		e === c
																			? ""
																			: ""
																	);
															}
															e = e === c ? r : c;
														}),
														(e = e === c ? r : c),
														process.stdout.write(
															"\n"
														);
												}),
												process.stdout.write(" "),
												n.map((t) => {
													process.stdout.write(
														"" + t
													);
												}),
												process.stdout.write("\n");
										})(this.board.configuration);
									}
									exportJson() {
										return this.board.exportJson();
									}
									exportFEN() {
										return (function (t) {
											let e = "";
											Object.assign([], o)
												.reverse()
												.map((i) => {
													let o = 0;
													i < 8 && (e += "/"),
														n.map((n) => {
															const s =
																t.pieces[n + i];
															s
																? (o &&
																		((e +=
																			o.toString()),
																		(o = 0)),
																  (e += s))
																: o++;
														}),
														(e += "" + (o || ""));
												}),
												(e +=
													t.turn === c
														? " w "
														: " b ");
											const {
												whiteShort: i,
												whiteLong: s,
												blackLong: r,
												blackShort: l,
											} = t.castling;
											return (
												s || i || r || l
													? (i && (e += "K"),
													  s && (e += "Q"),
													  l && (e += "k"),
													  r && (e += "q"))
													: (e += "-"),
												(e +=
													" " +
													(t.enPassant
														? t.enPassant.toLowerCase()
														: "-")),
												(e += " " + t.halfMove),
												(e += " " + t.fullMove),
												e
											);
										})(this.board.configuration);
									}
								}
								function J(t) {
									if (!t)
										throw new Error(
											"Configuration param required."
										);
									return new $(t).moves();
								}
								function V(t) {
									if (!t)
										throw new Error(
											"Configuration param required."
										);
									return new $(t).exportJson();
								}
								function Y(t) {
									if (!t)
										throw new Error(
											"Configuration param required."
										);
									return new $(t).exportFEN();
								}
								function z(t, e, i) {
									if (!t)
										throw new Error(
											"Configuration param required."
										);
									const n = new $(t);
									return (
										n.move(e, i),
										"object" == typeof t
											? n.exportJson()
											: n.exportFEN()
									);
								}
								function X(t, e = 2) {
									if (!t)
										throw new Error(
											"Configuration param required."
										);
									const i = new $(t).board.calculateAiMove(e);
									return { [i.from]: i.to };
								}
							},
						]);
					});
					return (
						(typeof window !== "undefined" &&
							window["js-chess-engine"]) ||
						(typeof this["js-chess-engine"] !== "undefined" &&
							this["js-chess-engine"]) ||
						null
					);
				})();
				window.jsChessEngine = jsChessEngine;
				var files = ["A", "B", "C", "D", "E", "F", "G", "H"];
				var ranks = ["1", "2", "3", "4", "5", "6", "7", "8"];
				var playerColor = "white";
				var boardFlipped = false;
				var game = new jsChessEngine.Game();
				var moveHistory = [];
				var gameNotation = [];
				var lastMove = null;
				var dragging = null;
				var engineThinking = false;
				var wins = parseInt(localStorage.getItem("chessWins") || "0");
				var losses = parseInt(
					localStorage.getItem("chessLosses") || "0"
				);
				var boardEl = document.getElementById("boardContainer");
				var statusEl = document.getElementById("statusBar");
				var notationEl = document.getElementById("notationContent");
				var winsEl = document.getElementById("winsCount");
				var lossesEl = document.getElementById("lossesCount");
				winsEl.textContent = wins;
				lossesEl.textContent = losses;
				function getPieceMap() {
					return game.exportJson().pieces;
				}
				function currentTurn() {
					return game.exportJson().turn;
				}
				function isPlayerTurn() {
					return currentTurn() === playerColor;
				}
				function coordToSquareDiv(file, rank) {
					return boardEl.querySelector(
						'.square[data-square="' + file + rank + '"]'
					);
				}
				function rebuildBoard() {
					boardEl.innerHTML = "";
					for (var r = 7; r >= 0; r--) {
						var row = document.createElement("div");
						row.className = "board-row";
						for (var f = 0; f < 8; f++) {
							var displayFile = files[f];
							var displayRank = ranks[r];
							if (boardFlipped) {
								displayFile = files[7 - f];
								displayRank = ranks[7 - r];
							}
							var sq = document.createElement("div");
							sq.className =
								"square " +
								((f + r) % 2 === 0 ? "light" : "dark");
							sq.dataset.square = displayFile + displayRank;
							var coordFile = document.createElement("div");
							coordFile.className = "coord file";
							coordFile.textContent = displayFile.toLowerCase();
							var coordRank = document.createElement("div");
							coordRank.className = "coord rank";
							coordRank.textContent = displayRank;
							sq.appendChild(coordFile);
							sq.appendChild(coordRank);
							attachSquareEvents(sq);
							row.appendChild(sq);
						}
						boardEl.appendChild(row);
					}
					renderPieces();
				}
				function renderPieces() {
					var squares = boardEl.querySelectorAll(".square");
					squares.forEach(function (sq) {
						var children = Array.from(sq.children);
						children.forEach(function (ch) {
							if (ch.classList.contains("piece"))
								sq.removeChild(ch);
						});
					});
					var pieces = getPieceMap();
					for (var sqName in pieces) {
						var symbol = pieces[sqName];
						var div = coordToSquareDiv(sqName[0], sqName[1]);
						if (!div) continue;
						var pieceEl = document.createElement("div");
						pieceEl.className = "piece";
						var isWhite = symbol === symbol.toUpperCase();
						if (isWhite) {
							pieceEl.classList.add("white");
						} else {
							pieceEl.classList.add("black");
						}
						pieceEl.textContent = pieceSymbol(symbol);
						pieceEl.dataset.piece = symbol;
						pieceEl.dataset.square = sqName;
						div.appendChild(pieceEl);
					}
					highlightLastMove();
				}
				function pieceSymbol(sym) {
					var map = {
						P: "",
						N: "",
						B: "",
						R: "",
						Q: "",
						K: "",
						p: "",
						n: "",
						b: "",
						r: "",
						q: "",
						k: "",
					};
					return map[sym] || sym;
				}
				function pieceToNotation(piece) {
					var map = { K: "K", Q: "Q", R: "R", B: "B", N: "N", P: "" };
					return map[piece.toUpperCase()] || "";
				}
				function updateNotation() {
					var html = "";
					for (var i = 0; i < gameNotation.length; i += 2) {
						var moveNum = Math.floor(i / 2) + 1;
						var white = gameNotation[i] || "";
						var black = gameNotation[i + 1] || "";
						html += '<span class="move-pair">';
						html +=
							'<span class="move-number">' + moveNum + ".</span>";
						html += white;
						if (black) {
							html += " " + black;
						}
						html += "</span>";
					}
					notationEl.innerHTML = html;
					notationEl.scrollTop = notationEl.scrollHeight;
				}
				function addMoveToNotation(from, to) {
					var pieces = getPieceMap();
					var piece = null;
					for (var sq in pieces) {
						if (sq === to) {
							piece = pieces[sq];
							break;
						}
					}
					if (!piece) return;
					var notation = pieceToNotation(piece);
					notation += from[0].toLowerCase() + from[1];
					notation += to[0].toLowerCase() + to[1];
					gameNotation.push(notation);
					updateNotation();
				}
				function attachSquareEvents(sq) {
					sq.addEventListener("mousedown", onPointerDown);
					sq.addEventListener("touchstart", onPointerDown, {
						passive: false,
					});
					sq.addEventListener("mousemove", onPointerMove);
					sq.addEventListener("touchmove", onPointerMove, {
						passive: false,
					});
					sq.addEventListener("mouseup", onPointerUp);
					sq.addEventListener("mouseleave", onPointerUp);
					sq.addEventListener("touchend", onPointerUp);
					sq.addEventListener("touchcancel", onPointerUp);
				}
				function onPointerDown(e) {
					if (engineThinking || !isPlayerTurn()) return;
					e.preventDefault();
					var sqDiv = e.currentTarget;
					var square = sqDiv.dataset.square;
					var pieces = getPieceMap();
					var sym = pieces[square];
					if (!sym) return;
					var isWhitePiece = sym === sym.toUpperCase();
					var playerIsWhite = playerColor === "white";
					if (
						(playerIsWhite && !isWhitePiece) ||
						(!playerIsWhite && isWhitePiece)
					)
						return;
					var pieceEl = sqDiv.querySelector(".piece");
					if (!pieceEl) return;
					dragging = { from: square, symbol: sym, elem: pieceEl };
					pieceEl.classList.add("dragging");
				}
				function onPointerMove(e) {
					if (!dragging) return;
					e.preventDefault();
				}
				function onPointerUp(e) {
					if (!dragging) return;
					e.preventDefault();
					var targetSquare = null;
					var touch = e.changedTouches && e.changedTouches[0];
					var x = touch ? touch.clientX : e.clientX;
					var y = touch ? touch.clientY : e.clientY;
					var elem = document.elementFromPoint(x, y);
					while (elem && !elem.classList.contains("square")) {
						elem = elem.parentElement;
					}
					if (elem && elem.classList.contains("square")) {
						targetSquare = elem.dataset.square;
					}
					var from = dragging.from;
					dragging.elem.classList.remove("dragging");
					dragging = null;
					if (!targetSquare || targetSquare === from) {
						renderPieces();
						return;
					}
					playerMove(from, targetSquare);
				}
				function playerMove(from, to) {
					try {
						var legal = game.moves(from) || [];
						if (legal.indexOf(to) === -1)
							throw new Error("Illegal move");
						game.move(from, to);
						moveHistory.push({ from: from, to: to });
						addMoveToNotation(from, to);
						lastMove = { from: from, to: to };
						renderPieces();
						checkStatus();
						if (!isGameOver() && !isPlayerTurn()) {
							window.setTimeout(engineTurn, 200);
						}
					} catch (err) {
						renderPieces();
					}
				}
				function engineTurn() {
					engineThinking = true;
					statusEl.textContent = "Engine thinking...";
					try {
						var mapped = Math.min(
							4,
							Math.max(
								0,
								Math.round(((currentDifficulty() - 1) * 4) / 9)
							)
						);
						var m = game.aiMove(mapped);
						var keys = Object.keys(m);
						var from = keys[0];
						var to = m[from];
						moveHistory.push({ from: from, to: to });
						addMoveToNotation(from, to);
						lastMove = { from: from, to: to };
						renderPieces();
						checkStatus();
					} catch (err) {
						console.error(err);
					}
					engineThinking = false;
				}
				function isGameOver() {
					return game.exportJson().isFinished;
				}
				function checkStatus() {
					var s = game.exportJson();
					if (s.checkMate) {
						var playerWon = s.turn !== playerColor;
						if (playerWon) {
							wins++;
							localStorage.setItem("chessWins", wins);
							winsEl.textContent = wins;
							showGameOverModal(true);
						} else {
							losses++;
							localStorage.setItem("chessLosses", losses);
							lossesEl.textContent = losses;
							showGameOverModal(false);
						}
					} else if (s.isFinished) {
						statusEl.textContent = "Game over - Draw.";
					} else if (s.check) {
						statusEl.textContent =
							(s.turn === "white" ? "White" : "Black") +
							" is in check.";
					} else {
						statusEl.textContent =
							(s.turn === "white" ? "White" : "Black") +
							"'s move.";
					}
					highlightLastMove();
				}
				function showGameOverModal(won) {
					var modal = document.getElementById("gameOverModal");
					var title = document.getElementById("gameOverTitle");
					if (won) {
						title.textContent = "You Won!";
						title.className = "won";
					} else {
						title.textContent = "You Lost";
						title.className = "lost";
					}
					modal.style.display = "flex";
				}
				function hideGameOverModal() {
					document.getElementById("gameOverModal").style.display =
						"none";
				}
				function highlightLastMove() {
					var sqs = boardEl.querySelectorAll(".square");
					sqs.forEach(function (sq) {
						sq.classList.remove("highlight-last");
					});
					if (!lastMove) return;
					var fromDiv = coordToSquareDiv(
						lastMove.from[0],
						lastMove.from[1]
					);
					var toDiv = coordToSquareDiv(
						lastMove.to[0],
						lastMove.to[1]
					);
					if (fromDiv) fromDiv.classList.add("highlight-last");
					if (toDiv) toDiv.classList.add("highlight-last");
				}
				function newGame() {
					playerColor = document.getElementById("colorSelect").value;
					boardFlipped = playerColor !== "white";
					game = new jsChessEngine.Game();
					moveHistory = [];
					gameNotation = [];
					lastMove = null;
					hideGameOverModal();
					updateNotation();
					rebuildBoard();
					checkStatus();
					if (playerColor !== "white") {
						engineThinking = true;
						statusEl.textContent = "Engine thinking...";
						setTimeout(function () {
							try {
								var mapped = Math.min(
									4,
									Math.max(
										0,
										Math.round(
											((currentDifficulty() - 1) * 4) / 9
										)
									)
								);
								var m = game.aiMove(mapped);
								var keys = Object.keys(m);
								var from = keys[0];
								var to = m[from];
								moveHistory.push({ from: from, to: to });
								addMoveToNotation(from, to);
								lastMove = { from: from, to: to };
								renderPieces();
								checkStatus();
							} catch (err) {
								console.error(err);
							}
							engineThinking = false;
						}, 200);
					}
				}
				function currentDifficulty() {
					return (
						parseInt(
							document.getElementById("difficulty").value,
							10
						) || 5
					);
				}
				function copyNotation() {
					var text = "";
					for (var i = 0; i < gameNotation.length; i += 2) {
						var moveNum = Math.floor(i / 2) + 1;
						text += moveNum + ". " + gameNotation[i];
						if (gameNotation[i + 1]) {
							text += " " + gameNotation[i + 1];
						}
						text += " ";
					}
					if (navigator.clipboard) {
						navigator.clipboard.writeText(text).then(function () {
							alert("Notation copied!");
						});
					} else {
						var textarea = document.createElement("textarea");
						textarea.value = text;
						document.body.appendChild(textarea);
						textarea.select();
						document.execCommand("copy");
						document.body.removeChild(textarea);
						alert("Notation copied!");
					}
				}
				function exportPGN() {
					var pgn = '[Event "Casual Game"]\n';
					pgn +=
						'[Date "' +
						new Date()
							.toISOString()
							.split("T")[0]
							.replace(/-/g, ".") +
						'"]\ n';
					pgn +=
						'[White "' +
						(playerColor === "white" ? "Player" : "Computer") +
						'"]\n';
					pgn +=
						'[Black "' +
						(playerColor === "black" ? "Player" : "Computer") +
						'"]\n\n';
					for (var i = 0; i < gameNotation.length; i += 2) {
						var moveNum = Math.floor(i / 2) + 1;
						pgn += moveNum + ". " + gameNotation[i];
						if (gameNotation[i + 1]) {
							pgn += " " + gameNotation[i + 1];
						}
						pgn += "\n";
					}
					var blob = new Blob([pgn], { type: "text/plain" });
					var url = URL.createObjectURL(blob);
					var a = document.createElement("a");
					a.href = url;
					a.download = "chess-game.pgn";
					document.body.appendChild(a);
					a.click();
					document.body.removeChild(a);
					URL.revokeObjectURL(url);
				}
				document
					.getElementById("difficulty")
					.addEventListener("input", function () {
						document.getElementById("difficultyValue").textContent =
							this.value;
					});
				document
					.getElementById("newGameBtn")
					.addEventListener("click", function () {
						if (engineThinking) return;
						newGame();
					});
				document
					.getElementById("flipBtn")
					.addEventListener("click", function () {
						if (engineThinking) return;
						boardFlipped = !boardFlipped;
						rebuildBoard();
					});
				document
					.getElementById("undoBtn")
					.addEventListener("click", function () {
						if (engineThinking || moveHistory.length === 0) return;
						game = new jsChessEngine.Game();
						var n = moveHistory.length;
						if (n >= 2) {
							moveHistory.pop();
							moveHistory.pop();
							gameNotation.pop();
							gameNotation.pop();
						} else {
							moveHistory.pop();
							gameNotation.pop();
						}
						for (var i = 0; i < moveHistory.length; i++) {
							game.move(moveHistory[i].from, moveHistory[i].to);
						}
						lastMove = moveHistory.length
							? moveHistory[moveHistory.length - 1]
							: null;
						updateNotation();
						renderPieces();
						checkStatus();
					});
				document
					.getElementById("copyBtn")
					.addEventListener("click", copyNotation);
				document
					.getElementById("exportBtn")
					.addEventListener("click", exportPGN);
				document
					.getElementById("playAgainBtn")
					.addEventListener("click", newGame);
				document
					.getElementById("closeModalBtn")
					.addEventListener("click", hideGameOverModal);
				newGame();
			})();
		</script>
	</body>
</html>
